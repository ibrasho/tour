الوظائف والواجهات
هذا الدرس يغطي الوظائف والواجهات: المكونات التي تعرف الأشياء وتصرفها.

مؤلفو Go
https://golang.org

* الوظائف (Methods)

Go لا تحتوى على أصناف.
ولكن بإمكانك تعريف الوظائف على الأنواع.

الوظيفة هي دالة لها معطى ـمستقبلـ خاص.

المستقبل يظهر في قائمة معطيات خاصة به بين كلمة `func` واسم الوظيفة.

في هذا المثال وظيفة `Abs` لها مستقبل من نوع `Vertex` اسمه `v`.

.play methods/methods.go

* الوظائف هي دوال (Methods are functions)

تذكر: الوظيفة هي دالة لها مستقبل معطى.

هنا `Abs` مكتوبة كدالة عادية بدون تغير في عملها.

.play methods/methods-funcs.go

* الوظائف (تابع)

بلإمكانك إعلان وظيفة على الأنواع غير التراكيب.

في هذا المثال نرى نوع رقمي  `MyFloat` له وظيفة `Abs`.

لا يمكنك إعلان وظيفة بمستقبل إلا إذا كان نوع المستقبل معرف في نفس الحزمة.
لا يمكنك إعلان وظيفة بمستقبل معرف في رمز آخرى (هذا يتضمن الأنواع المضمنة مثل `int`).

.play methods/methods-continued.go

* المستقبلات المؤشرات (Pointer receivers)

بإمكانك إعلان وظيفة بمستقبل مؤشر.

هذا يعني أن نوع المستقبل له الصيغة الحرفية `*T` لنوع `T`.
(أيضًا، `T` لا يمكن أن يكون مؤشرًا مثل `*int`.)

مثلًا: الوظيفة `Scale` معرف على `*Vertex`.

الوظائف المعرفة على مؤشرات بإمكانها تعديل القيمة التي يؤشر عليها
المستقبل (كما تفعل `Scale` هنا).
بما أن الوظائف تحتاج عادة للتعديل على المستقبل، المستقبلات المؤشرات أكثر
شيوعًا من المستقبلات القيم.

جرب إزالة الـ`*` من إعلان دالة `Scale` في سطر 16 وراقب كيف يتغير تصرف البرنامج.

باستخدام مستقبل قيمة، وظيفة `Scale` تتعامل مع نسخة من قيمة `Vertex` الأصلية.
(هذا نفس التصرف لأي معطى دالة.)
طريقة `Scale` يجب أن تكون على مستقبل مؤشر لتغير قيمة`Vertex` المعلنة في دالة `main`.

.play methods/methods-pointers.go

* المؤشرات والدوال (Pointers and functions)

لقد أعدنا كتابة الطريقتين `Abs` و `Scale` كدوال.

مجددًا، جرب أن تزيل الـ `*` من سطر 16.
هل تستطيع معرفة لماذا تغير تصرف البرنامج؟
ماذا ينبغي أن نغير أيضًا لنتمكن من ترجمة البرنامج؟


(إذا لم تكن متأكدًا، أكمل للصفحة التالي.)

.play methods/methods-pointers-explained.go

* الطرق وعكس المؤشرات (Methods and pointer indirection)

بالمقارنة بالبرنامجين السابقين، بإمكانك ملاحظة أن الدوال بمعطى مؤشر يجب أن تعطى نوع مؤشر:

	var v Vertex
	ScaleFunc(v, 5)  // Compile error!
	ScaleFunc(&v, 5) // OK

بينما الطرق بمستقبل مؤشر يمكن أن تستدعى على مستقبل قيمة أو مؤشر:

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

للعبارة `v.Scale(5)`، وعلى الرغم من كون `v` قيمة وليست مؤشرًا،
الطريقة المعرفة على المؤشر تستدعى تلقائيًا.
وهذا لأن Go تفهم العبارة `v.Scale(5)` كما لو كانت
`(&v).Scale(5)` لأن الطريقة `Scale` لها مستقبل مؤشر.

.play methods/indirection.go

* الطرق وعكس المؤشرات (2)

الشيء المكافئ يحصل في الاتجاه المعاكس كذلك.

الدوال التي تأخذ معطى قيمة يجب أن تعطى قيمة من ذلك النوع المحدد:

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Compile error!

بينما القيم المعرفة على مستقبل قيمة يمكن أن تستدعى على مستقبل قيمة أو مؤشر:

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

في هذه الحالة، استدعاءالطريقة `p.Abs()` يفهم كما لو كان `(*p).Abs()`.

.play methods/indirection-values.go

* اختيار المستقبل كمؤشر أو كقيمة

هناك سببان لاستخدام مستقبل مؤشر.

الأول هو لتمكين الطريقة من تعديل القيمة التي يؤشر عليها المستقبل.

الثاني هو لتفادي نسخ القيمة في كل استدعاء طريقة.
هذا يؤدي لآداء أفضل إذا كان المستقبل تركيب كبير الحجم.

في هذا المثال، كلا `Scale` و `Abs` لها نوع المستقبل `*Vertex`،
على الرغم من أن طريقة  `Abs` لا تحتاج لتعديل مستقبلها.

على العموم، كل الطرق على نوع محدد ينبغي أن تعرف على مستقبل قيمة أو مؤشرًا، وليس خليطًا من النوعين.
(سنخرج لماذا في الدروس القادمة.)

.play methods/methods-with-pointer-receivers.go

* الواجهات (Interfaces)

_نوع_واجهة_ يعرف كمجموعة من تواقيع الدوال (method signatures).

القيم من نوع واجهة يمكن أن تحمل أي قيمة تطبق هذه الدوال.

*ملاحظة:* هنا خطأ في كود المثال في السطر 22.
`Vertex` (نوع قيمة) لا يطبق `Abser` لأن طريقة `Abs` معرفة على `*Vertex` (نوع مؤشر).

.play methods/interfaces.go

* الواجهات تطبق بشكل ضمني (Interfaces are implemented implicitly)

النوع يطبق الواجهة بمجرد تطبيق طرقها.
لا توجد إعلان صريح لنية التطبيق، ولا كلمة مفتاحية تقابل "implements".

الواجهات الضمنية تفصل تعريف الواجهة من تطبيقاتها،
وهذا يمكن التطبيقات مع الظهور في أي حزمة بدون ترتيب مسبق.

.play methods/interfaces-are-satisfied-implicitly.go

* قيم الواجهات (Interface values)

تحت الغطاء، قيم الواجهات يمكن اعتبارها زوج من قيمة ونوع محدد:

	(value, type)

قيمة الواجهة تحمل قيمة من نوع محدد.

استعداء طريقة على نوع واجهة ينفذ الطريقة على النوع المحدد.

.play methods/interface-values.go

* قيم الواجهات الحاوية لقيم ضمنية معدومة

إذا كانت القيمة المحددة داخل الواجهة هي العدم `nil`،
الطريقة ستستدعى على مستقبل معدوم.

في بعض اللغات هذا سيسبب استثناء مؤشر فارغ (null pointer exception)،
ولكن في Go من المعتاد كتابة الطرق بشكل يتعامل بلطافة في حال
استدعائها على مستقبل معدوم (كما في الطريقة `M` في هذا المثال.)

لاحظ أن قيمة الواجهة التي تحمل قيمة محددة معدومة غير معدومة في ذاتها.

.play methods/interface-values-with-nil.go

* القيمة المعدومة للواجهة (Nil interface values)

قيمة الواجهة المعدومة لا تحمل قيمة أو نوع محدد.

استدعاء طريقة على واجهة معدومة سيسبب خطأ تشغيل لعدم وجود نوع داخل المجموعة يحدد ما هي الطريقة _المعرفة_ التي يجب أن تستدعى.

.play methods/nil-interface-values.go

* الواجهة الفارغة (The empty interface)

نوع الواجهة الذي لا يعرف أي وظائف يسمى _واجهة_فارغة_:

	interface{}

الواجهة الفارغة يمكن أن تحمل قيمة من أي نوع.
(كل الأنوع تطبق هذه الواجهة.)

الواجهة الفارغة تستخدم في الأكواد التي تحوي قيم غير معروفة النوع.
مثلًا، `fmt.Print` تأخذ أي عدد من المعطيات من النوع `interface{}`.

.play methods/empty-interface.go

* تأكيد النوع (Type assertions)

_تأكيد_النوع_ يمكّن من الوصول للقيمة المحددة في قيمة واجهة.

	t := i.(T)

هذه العبارة تؤكد أن قيمة الواجهة `i` تحمل النوع المحدد `T`
وتسند القيمة الضمنية `T` للمتغير `t`.

إذا كانت `i` تحمل قيمة ليست من نوع `T`، هذه العبارة ستسبب هلع (panic).

لاختبار ما إذا كانت قيمة واجهة تحمل نوع معين،
تأكيد النوع يرجع قيمتين: القيمة الضمنية وقيمة بولية تعبر عن نتيجة التأكيد.

	t, ok := i.(T)

إذا كانت `i` تحمل قيمة من نوع `T`، ستكون `t` القيمة الضمنية و `ok` ستكون `true`.

وإذا لم تكون تحمل النوع المطلوب، فستكون `ok` تساوي `false` و `t` ستكون القيمة الصفرية للنوع `T`، ولن يسبب هذا هلعًا,

لاحظ التشابه بين هذه الصيغة وبين القراءة من خريطة.

.play methods/type-assertions.go

* قواطع النوع

_قاطع_النوع_ هو تركيب يسمح بمجموعة متسلسلة من تأكيدات النوع.

قاطع النوع يشبه عبارة القاطع العادي، ولكن في حالات قاطع النوع تحدد الأنوع
(بدلًا من القيم)، وهذه القيم تحسب مقابل نوع القيمة المحفوظة في نوع الواجهة المعطى.

	switch v := i.(type) {
	case T:
		// here v has type T
	case S:
		// here v has type S
	default:
		// no match; here v has the same type as i
	}

الإعلان في قاطع النوع له نفس صيغة تأكيد النوع `i.(T)`،
ولكن النوع المحدد `T` يستبدل بالكلمة المفتاحية `type`.

عبارة القاطع تختبر ما أذا كانت قيمة الواجهة `i`
تحمل قيمة من أحد الأنواع `T` أو `S`.
في كل من حالات `T` و `S`، المتغير `v` سيكون من الأنواع
`T` أو `S` على التعاقب ويحمل القيمة المضمنة في `i`.

في الحالة الافتراضية (عندما عدم التوافق)، القيمة `v` لها نفس نوع وقيمة `i`.

.play methods/type-switches.go

* المسلسلات (Stringers)

واحدة من أكثر الواجهات شيوعًا هي [[//golang.org/pkg/fmt/#Stringer][`Stringer`]]
المعرفة في حزمة [[//golang.org/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

`Stringer` هو نوع يمكنه وصف نفسه كسلسلة (string). حزمة `fmt` (وحزم أخرى)
تبحث عن هذه الواجهة لطباعة القيم.

.play methods/stringer.go

* تمرين: المسلسلات

اجعل نوع `IPAddr` يطبق `fmt.Stringer` لطباعة العنوان كرباعي منقوط.

كمثال، `IPAddr{1,`2,`3,`4}` يبنغي أن يطبع بالشكل التالي `"1.2.3.4"`.

.play methods/exercise-stringer.go

* الأخطاء

برامج Go تعبر عن حالات الخطأ بقيم `error`.

نوع `error` معرف كنوع مضمن مثل `fmt.Stringer`:

	type error interface {
		Error() string
	}

(وكما في حالة `fmt.Stringer`، حزمة `fmt` تبحث عن واجهة `error` عند طباعة القيم.)

الدوال ترجع بالعادة قيمة `error`، والكود المستدعي ينبغي أن يعالج الأخطاء
بالتحقق من كون الخطأ معدومًا (يساوي `nil`).

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

الخطأ المعدوم يعني النجاخ، والخطأ غير المعدوم (non-nil) يعني الفشل.

.play methods/errors.go

* تمرين: الأخطاء

انسخ دالة `Sqrt` من [[/flowcontrol/8][التمرين السابق]] وعدلها لترجع قيمة `error`.

ينبغي أن ترجع `Sqrt` خطأ غير معدوم (non-nil) عندما تعطى رقم سالب، لأنها لا تدعم الأرقام المعقدة.

أنشئ نوع جديد

	type ErrNegativeSqrt float64

وأجعله من نوع `error` بتعريف طريقة

	func (e ErrNegativeSqrt) Error() string

بحيث تكون `ErrNegativeSqrt(-2).Error()` ترجع `"cannot`Sqrt`negative`number:`-2"`.

*ملاحظة:* استدعاء `fmt.Sprint(e)` داخل طريقة `Error` سيجعل البرنامج يعلق في تكرار لا نهائي. بإمكانك تفادي ذلك بتحويل `e` أولًا: `fmt.Sprint(float64(e))`. لماذا?

غيّر دالة `Sqrt` لترجع قيمة من نوع `ErrNegativeSqrt` عندما تعطى رقم سالب.

.play methods/exercise-errors.go

* القراء (Readers)

حزمة `io` تحدد واجهة `io.Reader` التي تمثل طرف القراءة من دفق بيانات.

المكتبة المعيارية في Go تحتوي على [[https://golang.org/search?q=Read#Global][تطبيقات كثيرة]] لهذه الواجهات، تتضمن الملفات واتصالات الشبكة والضاغطات والشفرات وأشياء آخرى.

واجهة `io.Reader` لديها وظيفة `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` تملأ شريحة البايتات بالبيانات وترجع عدد البايتات المعبئة وقيمة خطأ.
عندما ينتهي الدفق الخطأ سيكون `io.EOF`.

هذا المثال ينشئ
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
ويستهلك 8 بت من مخرجاته في كل مرة.

.play methods/reader.go

* تمرين: القراء (Readers)

طبق نوع `Reader` يخرج دفق لا نهائي من حرف ASCII `'A'`.

.play methods/exercise-reader.go

* تمرين: rot13Reader

من الأنماط المتكررة [[https://golang.org/pkg/io/#Reader][io.Reader]] يحيط بـ`io.Reader` آخر، معدلًا الدفق بطريقة ما.

على سبيل المثال، دالة [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] تأخذ `io.Reader` (دفق من البيانات المضغوطة) وترجع `*gzip.Reader` يطبق `io.Reader` (دفق من البيانات مفكوكة الضغط).

طبّق `rot13Reader` يطبق `io.Reader` ويقرأ من `io.Reader`، معدلًا على الدفق بتنفيذ شفرة [[https://en.wikipedia.org/wiki/ROT13][rot13]] التبدالية لكل الحروف الهجائية.

نوع `rot13Reader` مقدم لك.
اجعله `io.Reader` بتطبيق وظيفة `Read`.

.play methods/exercise-rot-reader.go

* تمرين: الصور

[[https://golang.org/pkg/image/#Image][حزمة image]] تعرف واجهة `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*ملاحظة*: نوع المرجع `Rectangle` لوظيفة `Bounds` هو فعليًا
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]]،
لأن الإعلان في داخل حزمة `image`.

(اطلع على [[https://golang.org/pkg/image/#Image][التوثيق]] لجميع التفاصيل.)

الأنواع `color.Color` و `color.Model` هي أيضًا واجهات، ولكن سنتجاهل ذلك باستخدام التطبيقات `color.RGBA` و `color.RGBAModel`.
هذه الواجهات والأنواع محددة من [[https://golang.org/pkg/image/color/][حزمة image/color]]

.play methods/images.go

* تمرين: الصور

هل تذكر [[/moretypes/18][مولد الصور]] الذي كتبت مسبقًا؟
لنكتب مولدًا آخرًا، ولكن هذه المرة سيرجع  تطبيق لواجهة `image.Image` بدلًا من شريحة بيانات.

عرف نوع `Image` وطبق [[https://golang.org/pkg/image/#Image][الوظائف المطلوبة]]، واستدع `pic.ShowImage`.

`Bounds` ينبغى أن ترجع `image.Rectangle`، مثل `image.Rect(0,`0,`w,`h)`.

`ColorModel` ينبغي أن ترجع `color.RGBAModel`.

`At` ينبغي أن ترجع `color.Color`؛ قيمة `v` في مولد الصور الأخير تتماثل مع `color.RGBA{v,`v,`255,`255}` في هذا المولد.

.play methods/exercise-images.go

* مبروك!

لقد انهيت هذا الدرس!

بإمكانك العودة إلى  [[/list][القائمة]] لتختار ما تتعلمه، أو الاستمرار مع [[javascript:click('.next-page')][الدرس التالي]].
